import { Plugin } from 'vite'
import { MagicString } from '@napi-rs/magic-string'
import minimatch from 'minimatch'
import fs from 'fs'
import FastGlob from 'fast-glob'

type TransformContext = ThisParameterType<Plugin['transform']>

type Match = string | RegExp | Match[]

type MatchFn = (this: TransformContext, code: string, id: string) => boolean

const testMatch = (match: Match, testId: string): boolean => false
  || typeof match === 'string' && minimatch(testId, match)
  || match instanceof RegExp   && match.test(testId)
  || Array.isArray(match)      && match.some(m => testMatch(m, testId))

type PlainTextOptions = {
  namedExport?: string | false,
  dtsAutoGen?: boolean,
  distAutoClean?: boolean,
}

const defaultPlainTextOptions: Required<PlainTextOptions> = { namedExport: 'plainText', dtsAutoGen: false, distAutoClean: false }

/**
 * @param {string | RegExp | (string | RegExp)[] | Function} match - Predicate the module id(file name) matches and will be treat as plain text.
 * @note You can also pass a matching-predicator with this signature `(this: vite transform context, code: string, id: file name string) => void`.
 * @param {object=} [plainTextOptions={ namedExport: 'plainText', dtsAutoGen: false, distAutoClean: false }]
 * @param {string|false=} [plainTextOptions.namedExport='plainText'] - Specify the name of the named exporting or you can pass falsy value to use the default exporting.
 * @param {boolean=} [plainTextOptions.dtsAutoGen=false] - generate dts file for plain text file automatically.
 * @param {boolean=} [plainTextOptions.distAutoClean=false] - clean up the generated dts file after this plugin startup each time.
 * @returns Configured plugin
 */
export default function plainText (match: Match | MatchFn, options?: PlainTextOptions): Plugin {
  const plainTextOptions: Required<PlainTextOptions> = { ...{ namedExport: 'plainText', dtsAutoGen: false, distAutoClean: false }, ...options }
  const dtsBanner = `/** Generated by vite-plugin-plain-text, don't touch it **/`

  if (plainTextOptions.distAutoClean) {
    const dtsFiles = FastGlob.sync(['**/*.d.ts'], { ignore: ['node_modules'] })

    for (const dtsFile of dtsFiles) {
      if (fs.readFileSync(dtsFile, { encoding: 'utf-8' }).startsWith(dtsBanner)) {
        fs.unlinkSync(dtsFile)
      }
    }
  }

  return {
    name: 'plain text',
    transform (code, id) {
      if (typeof match === 'function' ? match.call(this, code, id) : testMatch(match, id)) {
        const magicString = new MagicString(code)

        // transform code
        {
          const transformed = plainTextOptions.namedExport
            // Named exporting
            ? `export const ${plainTextOptions.namedExport} = ${JSON.stringify(code)}`
            // Default exporting
            : (`const plainText = ${JSON.stringify(code)}` + '\n' + `export default plainText`)

          // ~~ effect ~~
          magicString.overwrite(0, code.length, transformed)
        }

        // type auto generation
        if (plainTextOptions.dtsAutoGen) {
          const dtsFile = id + '.d.ts'
          if (fs.existsSync(dtsFile) && !fs.readFileSync(dtsFile, { encoding: 'utf-8' }).startsWith(dtsBanner)) {
            console.warn(`Type declaration auto generation failed, please check file '${dtsFile}' can be maintained by vite-plugin-plain-text`)
          } else {
            const typeDeclaration = plainTextOptions.namedExport
              ? `export const ${plainTextOptions.namedExport}: string`
              : (`const plainText: string` + '\n' + `export default plainText`)

            fs.writeFileSync(id + '.d.ts', dtsBanner + '\n\n' + typeDeclaration)
          }

        }

        const sourcemap = this.getCombinedSourcemap()

        return {
          code: magicString.toString(),
          map: magicString.generateMap({ file: sourcemap.file, source: sourcemap.sources[0], includeContent: true }).toMap(),
        }
      }
    },
  }
}
